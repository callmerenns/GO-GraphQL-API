package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/altsaqif/go-graphql/cmd/delivery/middleware"
	"github.com/altsaqif/go-graphql/cmd/entity"
	"github.com/altsaqif/go-graphql/cmd/shared/common"
	"github.com/altsaqif/go-graphql/graph/generated"
	"github.com/altsaqif/go-graphql/graph/model"
	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Login is the resolver for the login field.
// @Summary Login user
// @Description Login user with email and password
// @Tags Authentication
// @Accept  json
// @Produce  json
// @Param   loginRequest body model.LoginRequest true "Login Request"
// @Success 200 {object} model.SingleLoginResponse
// @Failure 400 {object} model.Status
// @Failure 400 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /login [post]
func (r *mutationResolver) Login(ctx context.Context, input model.LoginRequest) (*model.LoginResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)
	userCh := make(chan entity.User, 1)
	errCh := make(chan error, 1)

	// Fetch user by email in a goroutine
	go func() {
		var user entity.User
		if err := r.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
			errCh <- errors.New("invalid email or password")
			return
		}
		userCh <- user
	}()

	// Validate password in a goroutine
	go func() {
		user := <-userCh
		if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
			errCh <- errors.New("invalid email or password")
			return
		}
		userCh <- user
	}()

	var user entity.User
	select {
	case user = <-userCh:
		// User is successfully fetched and password is valid
	case err := <-errCh:
		// Send error response and return
		common.SendErrorResponse400(c, err.Error())
		return nil, nil
	}

	// Create JWT token
	token, err := r.JwtService.CreateToken(&user)
	if err != nil {
		common.SendErrorResponse500(c, fmt.Sprintf("Failed to create token: %v", err))
		return nil, nil
	}

	// Set token to cookie
	c.SetCookie("token", token, int(time.Hour*72/time.Second), "/", "", false, true)

	// Construct response
	loginResponse := &model.LoginResponse{Message: token}

	// Send success response using SendSingleResponse
	common.SendSingleLoginResponse(c, "Login successful", loginResponse)

	return loginResponse, nil
}

// Register is the resolver for the register field.
// @Summary Register a new user
// @Description Register a new user with the given details
// @Tags Authentication
// @Accept json
// @Produce json
// @Param registerRequest body model.RegisterRequest true "Register Request"
// @Success 200 {object} model.SingleRegisterResponse
// @Failure 400 {object} model.Status
// @Failure 500 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /register [post]
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterRequest) (*model.RegisterResponse, error) {
	// Debug: Log the input request
	log.Printf("Register input: %+v\n", input)

	c := ctx.Value("ginContext").(*gin.Context)

	if input.Password != input.ConfirmPassword {
		common.SendErrorResponse400(c, "Passwords do not match")
		return nil, nil
	}

	hashedPasswordCh := make(chan string, 1)
	errCh := make(chan error, 1)

	// Hash the password in a goroutine
	go func() {
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
		if err != nil {
			errCh <- fmt.Errorf("failed to hash password: %v", err)
			return
		}
		hashedPasswordCh <- string(hashedPassword)
	}()

	var user entity.User

	// Wait for hashed password or error
	select {
	case hashedPassword := <-hashedPasswordCh:
		user = entity.User{
			FirstName: input.Firstname,
			LastName:  input.Lastname,
			Email:     input.Email,
			Password:  hashedPassword,
			Role:      input.Role,
		}
	case err := <-errCh:
		common.SendErrorResponse500(c, err.Error())
		return nil, nil
	}

	// Debug: Log the user entity before saving
	log.Printf("Creating user: %+v\n", user)

	// Save the user in a goroutine
	go func() {
		if err := r.DB.Create(&user).Error; err != nil {
			errCh <- fmt.Errorf("failed to create user: %v", err)
			return
		}
		hashedPasswordCh <- ""
	}()

	select {
	case <-hashedPasswordCh:
		userResponse := &model.RegisterResponse{
			ID:        strconv.FormatUint(uint64(user.ID), 10),
			Firstname: user.FirstName,
			Lastname:  user.LastName,
			Email:     user.Email,
			Role:      user.Role,
			CreatedAt: formatTime(user.CreatedAt),
			UpdatedAt: formatTime(user.UpdatedAt),
			DeletedAt: formatTime(user.DeletedAt.Time),
		}
		// Send success response using SendCreateResponse
		common.SendCreateRegisterResponse(c, "User created successfully", userResponse)
		return userResponse, nil
	case err := <-errCh:
		common.SendErrorResponse500(c, err.Error())
		return nil, nil
	}
}

// Logout is the resolver for the logout field.
// @Summary Logout the current user
// @Description Clears the authentication token and logs out the current user
// @Tags Authentication
// @Accept json
// @Produce json
// @Param logoutRequest body model.LogoutRequest true "Logout Request"
// @Success 200 {object} model.SingleLogoutResponse
// @Router /logout [post]
func (r *mutationResolver) Logout(ctx context.Context, input model.LogoutRequest) (*model.LogoutResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	authHeader := c.GetHeader("Authorization")
	if authHeader == "" {
		common.SendErrorResponse500(c, "No Authorization header found")
		return nil, fmt.Errorf("no Authorization header found")
	}

	parts := strings.Split(authHeader, " ")
	if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
		common.SendErrorResponse500(c, "Invalid Authorization header format")
		return nil, fmt.Errorf("invalid Authorization header format")
	}
	token := parts[1]

	// Add the token to the blacklist synchronously
	err := r.Blacklist.Add(token)
	if err != nil {
		common.SendErrorResponse500(c, fmt.Sprintf("Failed to add token to blacklist: %v", err))
		return nil, err
	}
	log.Printf("Token %s has been added to blacklist", token)

	logoutResponse := &model.LogoutResponse{Message: "Successfully logged out"}
	common.SendSuccessLogoutResponse(c, logoutResponse)
	return logoutResponse, nil
}

// CreateProduct is the resolver for the createProduct field.
// @Summary Create a new product
// @Description Creates a new product and associates it with the current user
// @Tags Products
// @Accept json
// @Produce json
// @Param productRequest body model.ProductRequest true "Product Request"
// @Success 201 {object} model.SingleProductResponse
// @Failure 401 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /product [post]
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductRequest) (*model.ProductResponse, error) {
	// Retrieve gin context
	c := ctx.Value("ginContext").(*gin.Context)

	// Retrieve user from context
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		// Send error response for unauthorized access
		common.SendErrorResponse401(c, "Unauthorized")
		return nil, err
	}

	product := entity.Product{
		Name:        input.Name,
		Description: input.Description,
		Stock:       input.Stock,
		Price:       input.Price,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
		Users:       []*entity.User{user}, // Add user to product relationship
	}

	doneCh := make(chan struct{})
	errCh := make(chan error, 1)

	// Goroutine to save the product to the database
	go func() {
		defer close(doneCh)
		if err := r.DB.Create(&product).Error; err != nil {
			errCh <- fmt.Errorf("failed to create product: %v", err)
			return
		}
	}()

	select {
	case <-doneCh:
		// Prepare the product response
		productResponse := &model.ProductResponse{
			ID:          strconv.FormatUint(uint64(product.ID), 10),
			Name:        product.Name,
			Description: product.Description,
			Stock:       product.Stock,
			Price:       product.Price,
			CreatedAt:   formatTime(product.CreatedAt),
			UpdatedAt:   formatTime(product.UpdatedAt),
			DeletedAt:   formatDeletedAt(product.DeletedAt),
		}

		// Send create response
		common.SendCreateProductResponse(c, "Product created successfully", productResponse)

		return productResponse, nil
	case err := <-errCh:
		// Send error response for internal server error
		common.SendErrorResponse500(c, err.Error())
		return nil, err
	}
}

// UpdateProduct is the resolver for the updateProduct field.
// @Summary Update an existing product
// @Description Updates the fields of an existing product and associates the current user with it
// @Tags Products
// @Accept json
// @Produce json
// @Param id path string true "Product ID"
// @Param productRequest body model.ProductRequest true "Product Request"
// @Success 200 {object} model.SingleProductResponse
// @Failure 401 {object} model.Status
// @Failure 404 {object} model.Status
// @Failure 500 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /product/{id} [put]
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductRequest) (*model.ProductResponse, error) {
	// Retrieve gin context
	c := ctx.Value("ginContext").(*gin.Context)

	// Channel untuk sinyal selesai dan error
	doneCh := make(chan struct{})
	errCh := make(chan error, 1)

	var product entity.Product
	go func() {
		defer close(doneCh)
		// Retrieve product by ID
		if err := r.DB.Where("id = ?", id).First(&product).Error; err != nil {
			errCh <- fmt.Errorf("product not found")
			return
		}
	}()

	select {
	case <-doneCh:
		// Retrieve user from context
		user, err := middleware.GetUserFromContext(ctx)
		if err != nil {
			common.SendErrorResponse401(c, "Unauthorized")
			return nil, fmt.Errorf("failed to get user from context: %v", err)
		}

		// Update product fields
		product.Name = input.Name
		product.Description = input.Description
		product.Stock = input.Stock
		product.Price = input.Price
		product.UpdatedAt = time.Now()

		doneUpdateCh := make(chan struct{})
		errUpdateCh := make(chan error, 1)

		// Goroutine untuk menyimpan produk yang diperbarui ke database
		go func() {
			defer close(doneUpdateCh)
			if err := r.DB.Save(&product).Error; err != nil {
				errUpdateCh <- fmt.Errorf("failed to update product: %v", err)
				return
			}
		}()

		select {
		case <-doneUpdateCh:
			// Goroutine untuk menambahkan user ke produk jika belum ditambahkan
			go func() {
				if err := r.DB.Model(&product).Association("Users").Append(user); err != nil {
					errCh <- fmt.Errorf("failed to add user to product: %v", err)
					return
				}
			}()

			// Prepare the product response
			productResponse := &model.ProductResponse{
				ID:          strconv.FormatUint(uint64(product.ID), 10),
				Name:        product.Name,
				Description: product.Description,
				Stock:       product.Stock,
				Price:       product.Price,
				CreatedAt:   formatTime(product.CreatedAt),
				UpdatedAt:   formatTime(product.UpdatedAt),
				DeletedAt:   formatDeletedAt(product.DeletedAt),
				Users:       []*model.UserResponse{},
			}

			// Populate the users field in the product response
			for _, u := range product.Users {
				productResponse.Users = append(productResponse.Users, &model.UserResponse{
					ID:        strconv.FormatUint(uint64(u.ID), 10),
					Firstname: u.FirstName,
					Lastname:  u.LastName,
					Email:     u.Email,
					Password:  u.Password,
					Role:      u.Role,
					CreatedAt: formatTime(u.CreatedAt),
					UpdatedAt: formatTime(u.UpdatedAt),
					DeletedAt: formatDeletedAt(u.DeletedAt),
				})
			}

			// Send success response
			common.SendSuccessProductResponse(c, productResponse)

			return productResponse, nil
		case err := <-errUpdateCh:
			// Send error response for internal server error
			common.SendErrorResponse500(c, err.Error())
			return nil, err
		}
	case err := <-errCh:
		// Send error response for product not found
		common.SendErrorResponse404(c, "Product not found")
		return nil, err
	}
}

// DeleteProduct is the resolver for the deleteProduct field.
// @Summary Delete a product by ID
// @Description Deletes a product based on its unique ID
// @Tags Products
// @Accept json
// @Produce json
// @Param id path string true "Product ID"
// @Success 200 {object} model.Status
// @Failure 404 {object} model.Status
// @Failure 500 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /product/{id} [delete]
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (*model.Status, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channel untuk sinyal selesai dan error
	doneCh := make(chan struct{})
	errCh := make(chan error, 1)

	// Goroutine untuk mengecek keberadaan produk dan menghapusnya
	go func() {
		defer close(doneCh)

		var product entity.Product
		// Check if the product exists
		if err := r.DB.Where("id = ?", id).First(&product).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				errCh <- fmt.Errorf("product not found")
				return
			}
			errCh <- fmt.Errorf("failed to retrieve product: %v", err)
			return
		}

		// Delete the product
		if err := r.DB.Delete(&product).Error; err != nil {
			errCh <- fmt.Errorf("failed to delete product: %v", err)
			return
		}
	}()

	select {
	case <-doneCh:
		// Send success response
		common.SendSuccessDeleteProductResponse(c, &model.Status{Code: http.StatusOK, Message: "Product deleted successfully"})
		return &model.Status{Code: http.StatusOK, Message: "Product deleted successfully"}, nil
	case err := <-errCh:
		// Handle errors and send appropriate responses
		if err.Error() == "product not found" {
			common.SendErrorResponse404(c, "Product not found")
			return nil, err
		}
		common.SendErrorResponse500(c, err.Error())
		return nil, err
	}
}

// GetAllUsers is the resolver for the getAllUsers field.
// @Summary Get all users
// @Description Retrieves a list of all users with optional pagination
// @Tags Profiles
// @Accept json
// @Produce json
// @Param limit query int false "Limit number of users per page"
// @Param offset query int false "Offset number of users for pagination"
// @Success 200 {object} model.UserListResponse
// @Failure 500 {object} model.Status
// @Failure 500 {object} model.Status
// @Router /users [get]
func (r *queryResolver) GetAllUsers(ctx context.Context, limit int, offset int) (*model.UserListResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channels for signaling completion and errors
	usersCh := make(chan []entity.User)
	totalUsersCh := make(chan int64)
	errCh := make(chan error, 1)

	// Goroutine for fetching users
	go func() {
		var users []entity.User
		if err := r.DB.Preload("Products").Limit(limit).Offset(offset).Find(&users).Error; err != nil {
			errCh <- fmt.Errorf("failed to fetch users: %v", err)
			return
		}
		usersCh <- users
	}()

	// Goroutine for counting total users
	go func() {
		var totalUsers int64
		if err := r.DB.Model(&entity.User{}).Count(&totalUsers).Error; err != nil {
			errCh <- fmt.Errorf("failed to count users: %v", err)
			return
		}
		totalUsersCh <- totalUsers
	}()

	var users []entity.User
	var totalUsers int64

	// Wait for results or errors
	for i := 0; i < 2; i++ {
		select {
		case fetchedUsers := <-usersCh:
			users = fetchedUsers
		case count := <-totalUsersCh:
			totalUsers = count
		case err := <-errCh:
			common.SendErrorResponse500(c, err.Error())
			return nil, err
		}
	}

	// If no users found, return 404
	if len(users) == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return nil, nil
	}

	var userResponses []*model.UserResponse
	for _, u := range users {
		var products []*model.ProductResponse
		for _, p := range u.Products {
			products = append(products, &model.ProductResponse{
				ID:          strconv.FormatUint(uint64(p.ID), 10),
				Name:        p.Name,
				Description: p.Description,
				Stock:       p.Stock,
				Price:       p.Price,
				CreatedAt:   formatTime(p.CreatedAt),
				UpdatedAt:   formatTime(p.UpdatedAt),
				DeletedAt:   formatDeletedAt(p.DeletedAt),
			})
		}

		userResponses = append(userResponses, &model.UserResponse{
			ID:        strconv.FormatUint(uint64(u.ID), 10),
			Firstname: u.FirstName,
			Lastname:  u.LastName,
			Email:     u.Email,
			Password:  u.Password,
			Role:      u.Role,
			CreatedAt: formatTime(u.CreatedAt),
			UpdatedAt: formatTime(u.UpdatedAt),
			DeletedAt: formatDeletedAt(u.DeletedAt),
			Products:  products,
		})
	}

	payload := &model.UserListResponse{
		Total:  int(totalUsers),
		Limit:  limit,
		Offset: offset,
		Users:  userResponses,
	}

	common.SendPagedUserResponse(c, int(totalUsers), limit, offset, userResponses)

	return payload, nil
}

// GetUserByID is the resolver for the getUserByID field.
// @Summary Get user by ID
// @Description Retrieves a user by their ID
// @Tags Profiles
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} model.SingleUserResponse
// @Failure 404 {object} model.Status
// @Router /users/{id} [get]
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.UserResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channel for signaling completion and errors
	userCh := make(chan *entity.User, 1)
	errCh := make(chan error, 1)

	// Goroutine for fetching user
	go func() {
		defer close(userCh)
		defer close(errCh)
		var user entity.User
		if err := r.DB.Preload("Products").Where("id = ?", id).First(&user).Error; err != nil {
			errCh <- fmt.Errorf("user not found: %v", err)
			return
		}
		userCh <- &user
	}()

	// Wait for results or errors
	var user *entity.User

	select {
	case fetchedUser := <-userCh:
		user = fetchedUser
	case err := <-errCh:
		common.SendErrorResponse404(c, err.Error())
		return nil, err
	}

	// Construct user response
	userResponse := &model.UserResponse{
		ID:        strconv.FormatUint(uint64(user.ID), 10),
		Firstname: user.FirstName,
		Lastname:  user.LastName,
		Email:     user.Email,
		Password:  user.Password,
		Role:      user.Role,
		CreatedAt: formatTime(user.CreatedAt),
		UpdatedAt: formatTime(user.UpdatedAt),
		DeletedAt: formatDeletedAt(user.DeletedAt),
		Products:  []*model.ProductResponse{},
	}

	// Populate the products field in the user response
	for _, p := range user.Products {
		userResponse.Products = append(userResponse.Products, &model.ProductResponse{
			ID:          strconv.FormatUint(uint64(p.ID), 10),
			Name:        p.Name,
			Description: p.Description,
			Stock:       p.Stock,
			Price:       p.Price,
			CreatedAt:   formatTime(p.CreatedAt),
			UpdatedAt:   formatTime(p.UpdatedAt),
			DeletedAt:   formatDeletedAt(p.DeletedAt),
		})
	}

	// Send success response using SendSuccessResponse
	common.SendSuccessUserResponse(c, userResponse)

	return userResponse, nil
}

// GetAllProducts is the resolver for the getAllProducts field.
// @Summary Get all products
// @Description Retrieves all products with pagination support
// @Tags Products
// @Accept json
// @Produce json
// @Param limit query int false "Limit"
// @Param offset query int false "Offset"
// @Success 200 {object} model.ProductListResponse
// @Failure 500 {object} model.Status
// @Router /products [get]
func (r *queryResolver) GetAllProducts(ctx context.Context, limit int, offset int) (*model.ProductListResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channels for signaling completion and errors
	productsCh := make(chan []entity.Product)
	totalProductsCh := make(chan int64)
	errCh := make(chan error, 1)

	// Goroutine for fetching products
	go func() {
		var products []entity.Product
		if err := r.DB.Preload("Users").Limit(limit).Offset(offset).Find(&products).Error; err != nil {
			errCh <- fmt.Errorf("failed to fetch products: %v", err)
			return
		}
		productsCh <- products
	}()

	// Goroutine for counting total products
	go func() {
		var totalProducts int64
		if err := r.DB.Model(&entity.Product{}).Count(&totalProducts).Error; err != nil {
			errCh <- fmt.Errorf("failed to count products: %v", err)
			return
		}
		totalProductsCh <- totalProducts
	}()

	var products []entity.Product
	var totalProducts int64

	// Wait for results or errors
	for i := 0; i < 2; i++ {
		select {
		case fetchedProducts := <-productsCh:
			products = fetchedProducts
		case count := <-totalProductsCh:
			totalProducts = count
		case err := <-errCh:
			common.SendErrorResponse500(c, err.Error())
			return nil, err
		}
	}

	// If no products found, return 404
	if len(products) == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
		return nil, nil
	}

	var productResponses []*model.ProductResponse
	for _, p := range products {
		productResponse := &model.ProductResponse{
			ID:          strconv.FormatUint(uint64(p.ID), 10),
			Name:        p.Name,
			Description: p.Description,
			Stock:       p.Stock,
			Price:       p.Price,
			CreatedAt:   formatTime(p.CreatedAt),
			UpdatedAt:   formatTime(p.UpdatedAt),
			DeletedAt:   formatDeletedAt(p.DeletedAt),
			Users:       []*model.UserResponse{},
		}

		for _, u := range p.Users {
			userResponse := &model.UserResponse{
				ID:        strconv.FormatUint(uint64(u.ID), 10),
				Firstname: u.FirstName,
				Lastname:  u.LastName,
				Email:     u.Email,
				Password:  u.Password,
				Role:      u.Role,
				CreatedAt: formatTime(u.CreatedAt),
				UpdatedAt: formatTime(u.UpdatedAt),
				DeletedAt: formatDeletedAt(u.DeletedAt),
			}
			productResponse.Users = append(productResponse.Users, userResponse)
		}

		productResponses = append(productResponses, productResponse)
	}

	payload := &model.ProductListResponse{
		Total:    int(totalProducts),
		Limit:    limit,
		Offset:   offset,
		Products: productResponses,
	}

	common.SendPagedProductResponse(c, int(totalProducts), limit, offset, productResponses)

	return payload, nil
}

// GetProductByID is the resolver for the getProductByID field.
// @Summary Get a product by ID
// @Description Retrieves a product by its ID
// @Tags Products
// @Accept json
// @Produce json
// @Param id path string true "Product ID"
// @Success 200 {object} model.SingleProductResponse
// @Failure 404 {object} model.Status
// @Router /product/{id} [get]
func (r *queryResolver) GetProductByID(ctx context.Context, id string) (*model.ProductResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channels for signaling completion and errors
	productCh := make(chan entity.Product, 1)
	errCh := make(chan error, 1)

	// Goroutine for fetching product by ID
	go func() {
		defer close(productCh)
		defer close(errCh)

		var product entity.Product
		if err := r.DB.Preload("Users").Where("id = ?", id).First(&product).Error; err != nil {
			errCh <- fmt.Errorf("failed to fetch product: %v", err)
			return
		}
		productCh <- product
	}()

	// Wait for result or error
	var fetchedProduct entity.Product

	select {
	case fetchedProduct = <-productCh:
	case err := <-errCh:
		common.SendErrorResponse404(c, "Product not found")
		return nil, fmt.Errorf("product not found: %v", err)
	}

	// Prepare product response
	productResponse := &model.ProductResponse{
		ID:          strconv.FormatUint(uint64(fetchedProduct.ID), 10),
		Name:        fetchedProduct.Name,
		Description: fetchedProduct.Description,
		Stock:       fetchedProduct.Stock,
		Price:       fetchedProduct.Price,
		CreatedAt:   formatTime(fetchedProduct.CreatedAt),
		UpdatedAt:   formatTime(fetchedProduct.UpdatedAt),
		DeletedAt:   formatDeletedAt(fetchedProduct.DeletedAt),
		Users:       []*model.UserResponse{},
	}

	for _, u := range fetchedProduct.Users {
		userResponse := &model.UserResponse{
			ID:        strconv.FormatUint(uint64(u.ID), 10),
			Firstname: u.FirstName,
			Lastname:  u.LastName,
			Email:     u.Email,
			Password:  u.Password,
			Role:      u.Role,
			CreatedAt: formatTime(u.CreatedAt),
			UpdatedAt: formatTime(u.UpdatedAt),
			DeletedAt: formatDeletedAt(u.DeletedAt),
		}
		productResponse.Users = append(productResponse.Users, userResponse)
	}

	// Send success response
	common.SendSuccessProductResponse(c, productResponse)

	return productResponse, nil
}

// GetProductByStock is the resolver for the getProductByStock field.
// @Summary Get products by stock quantity
// @Description Retrieves products that match the specified stock quantity
// @Tags Products
// @Accept json
// @Produce json
// @Param stock query integer true "Stock quantity"
// @Success 200 {array} model.AnyProductResponse
// @Failure 404 {object} model.Status
// @Router /products/by-stock [get]
func (r *queryResolver) GetProductByStock(ctx context.Context, stock model.Stock) ([]*model.ProductResponse, error) {
	c := ctx.Value("ginContext").(*gin.Context)

	// Channels for signaling completion and errors
	productsCh := make(chan []entity.Product, 1)
	errCh := make(chan error, 1)

	// Goroutine for fetching products by stock
	go func() {
		defer close(productsCh)
		defer close(errCh)

		var products []entity.Product
		if err := r.DB.Preload("Users").Where("stock = ?", stock.Stock).Find(&products).Error; err != nil {
			errCh <- fmt.Errorf("failed to fetch products by stock: %v", err)
			return
		}
		productsCh <- products
	}()

	// Wait for results or errors
	var fetchedProducts []entity.Product

	select {
	case p := <-productsCh:
		fetchedProducts = p
	case err := <-errCh:
		common.SendErrorResponse500(c, err.Error())
		return nil, err
	}

	// If no products found, return 404
	if len(fetchedProducts) == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
		return nil, nil
	}

	// Prepare product responses
	var productResponses []*model.ProductResponse

	for _, product := range fetchedProducts {
		productResponse := &model.ProductResponse{
			ID:          strconv.FormatUint(uint64(product.ID), 10),
			Name:        product.Name,
			Description: product.Description,
			Stock:       product.Stock,
			Price:       product.Price,
			CreatedAt:   formatTime(product.CreatedAt),
			UpdatedAt:   formatTime(product.UpdatedAt),
			DeletedAt:   formatDeletedAt(product.DeletedAt),
			Users:       []*model.UserResponse{},
		}

		for _, u := range product.Users {
			userResponse := &model.UserResponse{
				ID:        strconv.FormatUint(uint64(u.ID), 10),
				Firstname: u.FirstName,
				Lastname:  u.LastName,
				Email:     u.Email,
				Password:  u.Password,
				Role:      u.Role,
				CreatedAt: formatTime(u.CreatedAt),
				UpdatedAt: formatTime(u.UpdatedAt),
				DeletedAt: formatDeletedAt(u.DeletedAt),
			}
			productResponse.Users = append(productResponse.Users, userResponse)
		}

		productResponses = append(productResponses, productResponse)
	}

	// Send success response using SendSuccessProductByStockResponse
	common.SendSuccessProductByStockResponse(c, productResponses)

	return productResponses, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func formatTime(t time.Time) string {
	return t.Format(time.RFC3339)
}
func formatDeletedAt(deletedAt gorm.DeletedAt) string {
	if deletedAt.Valid {
		return formatTime(deletedAt.Time)
	}
	return ""
}
